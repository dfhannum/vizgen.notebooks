---
title: "Seurat Walkthrough w.r.t Normalization"
author: "D. Ford Hannum"
date: "2023-05-23"
output: html_document
  toc: yes
  toc_depth: 3
  highlight: tango
  number_sections: true
  toc_float: yes
---

```{r setup, include=TRUE, echo = FALSE, message = FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE)
knitr::opts_knit$set(root.dir = '../data/mouse_brain_showcase/Slice-1_Replicate-1/')
library(Seurat)

# install.packages('arrow')
# install.packages('wkb')
# install.packages('sf')

library(ggplot2)
library(data.table)
```

# Introduction

Here I am going to go through the Seurat pipeline without including any of the cell segmentation (takes the Seurat object from ~4GB to < 1GB). In other notebooks we walk through how to include segmentation. I'd recommend viewing the segmentation in the browser, and there are other walkthroughs about how to include output from Seurat in the visualizer object. 

Here is the directory and the files that I will be working from: 

```{r}
# Indicating the directory where everything is stored
root_dir = '../data/mouse_brain_showcase/Slice-1_Replicate-1/'
print(root_dir)

list.files(root_dir)

```

# Reading into Seurat

The ReadVizgen function needs additional files like segmentation to work properly, but here I do not wish to incorporate those into the Seurat object because of size issues.

```{r,warning=FALSE}
# spat <- ReadVizgen(data.dir = root_dir)
# spat <- LoadVizgen(data.dir = root_dir)
```

Here I'll load the cell_by_gene and cell_metadata csv files, format them, then create a Seurat object.

Below we load the cell by gene matrix and do a couple of formatting steps.

```{r}
# fread reads files quickly and completely
# we want the data to be in a data frame to create a Seurat object
counts <- as.data.frame(data.table::fread(paste0(root_dir,'./cell_by_gene.csv')))

# The first column is our cell name so want to move that to row.names then delete it
# this way our data frame is all numeric
rownames(counts) <- as.character(counts$cell)
counts <- counts[,-1]

# print(paste0('We have ',dim(counts)[1],' cells and ',dim(counts)[2],' columns'))

# Many of the "genes" are blanks used for QC in the curation of the counts
# We will remove them from downstream analysis
# All the blanks start with Blank
blanks <- counts[,grepl('Blank', colnames(counts), ignore.case = T)]

# print(paste0('Of the ',dim(counts)[2], ' columns ', dim(blanks)[2]
#              , ' contain blank reads(?) which will be removed'))

# Only keeping genes
counts <- counts[,!grepl('Blank', colnames(counts), ignore.case = T)]

print(paste0('We have ', dim(counts)[1], ' cells and ',dim(counts)[2],' genes'))
```

Below we will load the metadata and make sure it is aligned with the counts matrix.

```{r}
md <- as.data.frame(data.table::fread(paste0(root_dir,'./cell_metadata.csv')))

# Changing the rowname to the cell name
rownames(md) <- md$EntityID

print(paste0('Are cell IDs are are the same in the metadata and count matrices? ',
             identical(rownames(md), rownames(counts))))
```

Creating a seurat object from the two data frames.

```{r}
# Rotating the count matrix to follow convention
counts <- t(counts)

# Creating the seurat object and calling it Vizgen
spat <- CreateSeuratObject(counts =  counts,
                           meta.data = md, 
                           assay = 'Vizgen')
```

Adding the cell centroid information from the metadata into a different part of the Seurat object for plotting functions.

```{r}
# Pulling out the centroid information from the metadata
centroids <- md[,c('center_x','center_y','EntityID')]

# Relabeling the columns to follow Seurat convention
colnames(centroids) <- c('x','y','cell')

# Putting the centroids into a Seurat centroid object
cents <- CreateCentroids(centroids)

# Creating an FOV, not sure this is completely necessary but here you could also
# add segmentation and transcripts
coords <- CreateFOV(
  coords = cents,
  type = "centroids",
  assay = 'Vizgen'
)

# Adding the FOV to the main Seurat object
spat[['image']] <- coords

# head(GetTissueCoordinates(spat[['image']][['centroids']]))
```

# Processing w/ Seurat

Following the same processing steps as [MERSCOPE vignette](https://satijalab.org/seurat/articles/spatial_vignette_2.html)

```{r}
# The recommended function to transform the data and get highly variable genes,
# which would be all of genes since we have fewer than the default 2,000
spat <- SCTransform(spat, assay = 'Vizgen', 
                    clip.range = c(-10,10),vars.to.regress = 'volume')

# Generating principal components for the data
spat <- RunPCA(spat, npcs = 30, features = rownames(spat))

# Generating 2D umap coordinates
spat <- RunUMAP(spat, dims = 1:30)

# Finding neighbors then clustering the cells
spat <- FindNeighbors(spat, reduction = 'pca', dims = 1:30)
spat <- FindClusters(spat, resolution = 0.3)
```

# Visualizations

The resulting UMAP projection contains 24 clusters.

```{r}
# Plotting the data using UMAP
DimPlot(spat, reduction = 'umap')
```

Using a Seurat function we can view these cells in their spatial context colour by their cluster.

```{r}
# Plotting the clusters onto their spatial coordinates in the tissue
ImageDimPlot(spat, fov = 'image', cols = 'polychrome', axes = TRUE)
```

The above image is crowded with 24 different colors (and oddly a lot of the space is actually white). Below we will just look at two clusters seperately.

```{r}
# Same thing as above but only plotting one cluster of cells at a time
p1 <- ImageDimPlot(spat, fov = "image", cols = "red", cells = WhichCells(spat, idents = 14))
p2 <- ImageDimPlot(spat, fov = "image", cols = "red", cells = WhichCells(spat, idents = 15))
p1 + p2
```

The first cluster of cells (14) is diespersed evenly(ish) throughout the tissue, whereas with cluster 15 we see a clear spatial distribution.

## Alternatives

I don't think the ImageDimPlots are visually pleasing, so I'm going to view them outside Seurat with ggplot2.

```{r}
# Plotting the spatial coordinates using ggplot
ggplot(spat@meta.data, aes(x = center_x, y = -center_y, colour = seurat_clusters)) +
  geom_point(size = .1) + # changing the point size so they overlap less
  coord_fixed() + # fixing the coordinates so we don't aritificially shift the image
  guides(colour = guide_legend(override.aes = list(size = 3))) + # making the legend points larger then the points in the image
  theme_bw() # adding a white background
```

```{r}
p1 <- ggplot(spat@meta.data[spat$seurat_clusters == 14,],
             aes(x = center_x, y = -center_y, colour = seurat_clusters)) +
  geom_point(size = .1) + 
  coord_fixed() + 
  ggtitle('Cluster 14') +
  theme_bw() +
  theme(legend.position = 'none')

p2 <- ggplot(spat@meta.data[spat$seurat_clusters == 15,],
             aes(x = center_x, y = -center_y, colour = seurat_clusters)) +
  geom_point(size = .1) + 
  coord_fixed() + 
  ggtitle('Cluster 15') +
  theme_bw() +
  theme(legend.position = 'none')

p1 + p2
```

# Marker Genes

Going to look for genes that are upregulated within the different clusters, then going to use these markers to help us define cell types.

```{r}
# Using the wilcoxon rank test to get the top markers for each cluster
# only.pos = TRUE; only returns genes that are higher in the target cluster
# min.pct = .5; the minimum percentage of cells that contain the given 
#    transcript in either of the two groups (target vs other)
markers <- FindAllMarkers(spat, only.pos = TRUE, min.pct = .5)
```

A table for the number of markers identified in each cluster

```{r}
table(markers$cluster)

markers$duplicated_ <- duplicated(markers$gene)

for (i in 1:dim(markers)[1]){
  # print(i)
  markers$duplicated_[i] <- markers$gene[i] %in% markers$gene[-i]
}

table(markers$cluster, markers$duplicated_)

temp <- as.data.frame(table(markers$cluster, markers$duplicated_))
temp$`Unique\nMarkers` <- ifelse(temp$Var2 == 'FALSE', 'TRUE','FALSE')
# temp
ggplot(temp, aes(x = Var1, y = Freq, fill = `Unique\nMarkers`)) +
  geom_bar(stat = 'identity') +
  theme_bw()
```

# Cluster Centroids

```{r}
centroids <- AverageExpression(spat)
centroids <- centroids$SCT

temp.cor <- cor(centroids, method = 'spearman')

hclust_ <- hclust(dist(temp.cor))

temp.cor <- reshape2::melt(temp.cor)

temp.cor$Var1_ordered <- factor(temp.cor$Var1,
                                levels = (hclust_$order - 1))

temp.cor$Var2_ordered <- factor(temp.cor$Var2,
                                levels = (hclust_$order - 1))

temp.cor$Correlation <- temp.cor$value
ggplot(temp.cor[temp.cor$value !=1,],
       aes(x = Var1_ordered, y = Var2_ordered, fill = Correlation)) +
  geom_tile() +
  scale_fill_gradient2(low = 'blue', mid = 'white', high = 'red',
                       midpoint = mean(temp.cor$value)) +
  xlab('') + ylab('')

```

```{r}
DimPlot(spat, label = T, label.box = T)
```

```{r}
for (i in 0:23){
  temp <- markers[markers$cluster == i,]$gene[1:5]
  print(i)
  print(paste0(temp,collapse = ' , '))
}
```

# QC

```{r}
FeaturePlot(spat, features = 'nCount_Vizgen')

ggplot(spat@meta.data, aes(x = nCount_Vizgen)) +
  geom_histogram() +
  scale_x_log10()

spat$nCount_log10 <- log10(spat$nCount_Vizgen)

FeaturePlot(spat, features = 'nCount_log10') + 
  scale_color_gradient2(low = 'blue', mid = 'lightgrey',
                        high = 'red', midpoint = 2.5)

VlnPlot(spat, features = 'nCount_log10', pt.size = 0) +
  geom_hline(yintercept = 2, linetype = 2, colour = 'red')

table(spat$seurat_clusters, spat$nCount_log10 > 2)
```

```{r}
ggplot(data = spat@meta.data, aes(x = volume)) +
  geom_histogram()

FeaturePlot(spat, features = 'volume') +
  scale_color_gradient2(low = 'blue', mid = 'lightgrey', high = 'red', midpoint = 1250)

VlnPlot(spat, features = 'volume', pt.size = 0)

ggplot(spat@meta.data, aes(x = nCount_log10, y = volume)) + 
  geom_point(size = .1) +
  theme_bw() +
  geom_smooth(method = 'lm') +
  ggpubr::stat_cor(method = 'spearman')

# ggplot(spat@meta.data, aes(x = nCount_log10, y = volume,
#                            colour = seurat_clusters)) + 
#   geom_point(size = .1) +
#   geom_smooth(method = 'lm', se = F) +
#   theme_bw() 
```

```{r}
spat$density <- spat$nCount_Vizgen / spat$volume

ggplot(spat@meta.data, aes(x = density)) + 
  geom_histogram() + theme_bw() 


FeaturePlot(spat, features = 'density') +
  scale_color_gradient2(low = 'blue', mid = 'lightgrey', high = 'red',
                        midpoint = mean(spat$density))
```


# Trying other normalization methods and seeing how much changes

## Basic Workflow

This is the standard workflow through Seurat which was implemented before SCTransform took precident.

```{r}
DefaultAssay(spat) <- 'Vizgen'
# spat@assays$Vizgen@data[1:10,1:10] == spat@assays$Vizgen@counts[1:10,1:10]
spat <- NormalizeData(spat)

cnt <- spat@assays$Vizgen@counts
# 
# tpm <- cnt
# lib.size <- colSums(cnt)
# 
# for (i in 1:dim(tpm)[2]){
#   tpm[,i] <- tpm[,i]/lib.size[i] * 1e4
# }
# 
# tpm.log <- log1p(tpm)
# 
# identical(tpm.log, spat@assays$Vizgen@data)

ggplot(spat@meta.data, aes(x = volume)) + geom_histogram()

# tpv <- cnt
# 
# for(i in 1:dim(tpv)[2]){
#   tpv[,i] <- tpv[,i]/spat$volume[i] * 1e3
# }
# 
# saveRDS(tpv,paste0(root_dir,'tpv.Rds'))

tpv <- readRDS(paste0(root_dir,'tpv.Rds'))

# tpv[1:10,1:10]
```

```{r}
tpv.long <- reshape2::melt(as.matrix(tpv))
head(tpv.long)
tpv.long
ggplot(tpv.long[tpv.long$value != 0,], aes(x = log(value))) +
  geom_histogram()
```

# Correlating two methods

```{r}
dim(tpv)

dim(tpv)
tpv[1:5,1:5]
dim(spat@assays$Vizgen@data)
colSums(spat@assays$Vizgen@data[,1:10])

cor_pearson <- c()
for (i in 1:dim(spat)[2]){
  # if (i %% 100 == 0){print(paste0(i,' out of ', dim(spat)[2]))}
  
  temp <- cor(tpv[,i],
              spat@assays$Vizgen@data[,i],
              method = 'pearson')
  cor_pearson <- c(cor_pearson,temp)
}
#
```

```{r}
spat$tpv_cor_pearson <- cor_pearson
```

```{r}
FeaturePlot(spat, features = 'tpv_cor_pearson', pt.size = .1) +
  scale_color_gradient2(low = 'blue', mid = 'lightgrey',
                        high = 'red', 
                        midpoint = mean(spat$tpv_cor_pearson))

FeaturePlot(spat, features = 'volume', pt.size = .1) +
  scale_color_gradient2(low = 'blue', mid = 'lightgrey',
                        high = 'red', 
                        midpoint = mean(spat$volume))

```

```{r}
VlnPlot(spat, features = 'tpv_cor_pearson', pt.size = 0)
RidgePlot(spat, features = 'tpv_cor_pearson')
```

```{r}
ggplot(spat@meta.data, aes(x = volume, y = tpv_cor_pearson)) +
  geom_point(size = .1) +
  ggpubr::stat_cor(method = 'spearman', colour = 'red',
                   label.x = 1500) +
  theme_bw() +
  geom_smooth(method = 'lm', se = F)
```

```{r}
DimPlot(spat)
```

```{r}
ggplot(spat@meta.data, aes(x = center_x, 
                           y = -center_y, color = seurat_clusters)) +
  geom_point(size = .1) + 
  theme_bw() 
```

# Parquet File

```{r}
list.files(paste0(root_dir,'extras/'))
```

